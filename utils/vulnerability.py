# 检测脆弱性, 返回约束矩阵C
import numpy as np
from CONST import *
from io_metric import *


def fragility_curve(half_wind_speed, wind_speed):
    # sigmoid 激活函数
    value = 1/(1+np.exp(wind_speed-half_wind_speed))
    return value


def vulnerability_single(wind_speed, category):
    value = 0
    if category == 'tower':
        value = 1 - fragility_curve(36, wind_speed)
    elif category == 'branch':
        value = 1 - fragility_curve(24, wind_speed)
    return value


def vulnerability_total(wind_speed, length, branch_num):
    tower_num = length//TOWER_SPAN + 1
    tower_value = 1 - (1-vulnerability_single(wind_speed, 'tower'))**tower_num
    branch_value = 1 - (1-vulnerability_single(wind_speed, 'branch'))**branch_num
    value_total = tower_value + branch_value - tower_value*branch_value
    if value_total >= VULNERABILITY_THRESHOLD:
        return 0
    else:
        return 1


def constraint(wind_speed):
    constraint_matrix = np.zeros([BUS_NUM,BUS_NUM])
    constraint_vector = []
    tmp = []
    net, W, D = io_metric()
    length, branch_num = distance()
    for i in range(BUS_NUM):
        for j in range(BUS_NUM):
            if W[i][j] == 1:
                constraint_matrix[i][j] = vulnerability_total(wind_speed, length[i][j], branch_num[i]+branch_num[j])
                if constraint_matrix[i][j] == 0:
                    tmp.append(i)
                    tmp.append(j)
            else:
                constraint_matrix[i][j] = np.inf
    [constraint_vector.append(x) for x in tmp if x not in constraint_vector]
    C = np.zeros([BUS_NUM,BUS_NUM-len(constraint_vector)+1])
    for i in range(BUS_NUM):
        if i in constraint_vector:
            C[i][0] = 1
        else:
            for j in range(BUS_NUM):
                if W[i][j] == 1:
                    if j not in constraint_vector:
                        num_actual = sum(i < j for i in constraint_vector)
                        C[i][j-num_actual] = 1
    return C

if __name__ == '__main__':
    constraint(56)
